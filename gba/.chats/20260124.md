# Instructions

## 初始化项目

这是一个 geektime bootcamp agent(GBA) ，它的主要功能是封装 claude agent sdk，让用户可以很方便的的围绕一个 reop来添加新功能。请把这个 Rust 项目转换成一个workspace，里面包含 crates/gba-core(core execute engine),crates/gba-pm(prompt manager), 以及 apps/gba-cli (command line interface)。生成的是一个 gba cli。所有的deps 放在 workspace 下，各个crate 通过： 'xx = {workspace = true}' 来引用。CLI 使用  clap / ratatui 来构建。 prompt manager 使用 minijinja 来构建。 core execute engine 使用 tokio / claude-agent-sdk-rs 0.6 来构建。所有 deps 都要使用最新版本。

倾向不要撰写代码，生成各个 crate 的skeletong 即可
不要使用 derive_builder 使用 typed_builder


gba项目是一个 geektime bootcamp agent(GBA) ，它的主要功能是封装 claude agent sdk，让用户可以很方便的的围绕一个 reop来添加新功能。该 Rust 项目的workspace中包含了 crates/gba-core(core execute engine),crates/gba-pm(prompt manager), 以及 apps/gba-cli (command line interface)。生成的是一个 gba cli。所有的deps 放在 workspace 下，各个crate 通过： 'xx = {workspace = true}' 来引用。CLI 使用  clap / ratatui 来构建。 prompt manager 使用 minijinja 来构建。 core execute engine 使用 tokio / claude-agent-sdk-rs 0.6 来构建。目前已经生成了crate 的skeletong，还没有撰写代码。

接下来根据截图，请生成设计文档：

- 包括核心架构的 ascii diagram，以及重要的流程。
- 各个crate 有清晰的职责和 public interface
- gba-core: 核心的执行引擎，根据不同场景下的prompt，调用claude agent sdk 来执行任务。务必提供非常精简可用的接口
- gba-pm:提示词管理器，负责加载、渲染、管理提示词。务必提供非常精简可用的接口
- gba-cli:命令行界面，负责与用户交互，并调用 gba-core 来执行任务。
- 代码结构尽可能职责单一，不要出现重复代码，follow SOLID principles，尽可能使用 Rust 的最新特性。
- 提供开发计划，包括每个阶段的任务。

设计文档放在 ./specs 下合适的位置

## 更新设计文档
请检查设计文档中是否有以下设计，如果没有请按照如下设计，更新 design spec：

1.task kind 应该有 verification
2.任务执行结果应该记录 turns /cost, 放在每个 feature 下面的 state.yml（需要定义它的结构）中，最后的 PR link 也放进去。
3.在 'gba-run' 过程中，如果中断，下次运行可以继续回复（在提示词里体现）。
4.预先思考好所有场景下的提示词，放在 crates/gba-pm/templates 下，我来 review。提示词用英文。

## 更新提示词
注意 init 的提示词应该还要生成 .gba / .trees 等目录，以及更改 .gitignore;
run/execute 的提示词最后要使用 gh cli 生成 pull request 并且提供详尽的 PR description；

请仔细review 提示词中的变量以及条件判断：
1. 是否有必要 - 我们要尽可能 follow convention over configuration
2. 是否能在 execution engine 的上下文提供

在设计 / 提示词中的 phases 是如何获得的？请说明

对比 design_by_tyrchern.md，看当前design.md都有哪些优缺点，列出来，根据之前的需求判断，如果需要更改design.md,请进行更改完善；

目前这些提示词哪些是作为 sys prompt 添加到 claude code系统提示词中，哪些是作为user prompt 来驱动完成工作？比如: ' gba init '的 user prompt 是什么？

根据上下文需求，在 crates/gba-pm/templates 中的模版需要区分 system prompt 和 user prompt吗？

我已经将 https://github.com/tyrchen/claude-agent-sdk-rs clone到了本地 /mycode/gba/vendors中，如果需要可以从这里来了解 claude-agent-sdk-rs库中的内容

之前将 https://github.com/tyrchen/claude-agent-sdk-rs clone到了 /mycode/vendors中，放错了目录，现将 claude-agent-sdk-rs库的代码移动到了/mycode/gba/vendors下。

crates/gba-pm/templates下的模版是否可以根据init,observe,build,test,verification,review,pr等步骤来创建文件夹，然后再在每个步骤文件夹下分别放 system.md 和 user.md提示词模版。

在做system.md 和 user.md 提示词模版分离时，下面的方式：
phases:
    - name: "build"
      system_prompt: "build/system.md"     # 角色定义
      user_prompt: "build/user.md"         # 任务描述
      description: "Build implementation"
和目前 design.md 4.2 中的
phases:
  - name: "observe"
    description: "Observe codebase and understand context"
    # Loads: observe/system.md + observe/user.md

  - name: "build"
    description: "Build implementation"
    # Loads: build/system.md + build/user.md

  - name: "test"
    description: "Write and run tests"
    # Loads: test/system.md + test/user.md

  - name: "verification"
    description: "Verify implementation against requirements"
    # Loads: verification/system.md + verification/user.md

  - name: "review"
    description: "Code review and refinement"
    # Loads: review/system.md + review/user.md

  - name: "pr"
    description: "Create pull request"
    # Loads: pr/system.md + pr/user.md
```
配置，哪个更好，更符合 约定优于配置 原则。


同意，另外，请思考在不同的场景下，哪些需要 claude code preset，哪些不需要，哪些需要完整的工具，哪些不需要，这个应该在哪里定义，是写在 engine 中，还是配置中？

preset 不需要这么复杂吧？应该就是使用 claude code preset与否，请查看 /mycode/gba/vendors/claude-agent-sdk-rs/API.md 文档。如果每个任务都有 config.yml, 那么是否还合适放在 crates/gba-pm 下？ 或者 templates 直接放在根目录下，改个其他目录名？

API 文档：/mycode/gba/vendors/claude-agent-sdk-rs/API.md。preset true/false 即可。如果true，使用：
let options = ClaudeAgentOptions {
        system_prompt: Some(SystemPrompt::Preset(SystemPromptPreset::with_append(
            "claude_code",
            "Always end your response with a fun fact.",
        ))),
        model: Some("sonnet".to_string()), // Use Sonnet for lower cost
        ..Default::default()
    };
如果 false，使用：
let options = ClaudeAgentOptions {
        system_prompt: Some(SystemPrompt::Text(
            "You are a pirate assistant. Respond in pirate speak.".to_string(),
        )),
        model: Some("sonnet".to_string()), // Use Sonnet for lower cost
        ..Default::default()
    };
另外， Option<Vec<T>>没必要，Vec<T> 即可，如果为空，表示全部支持（比如：tools: [], 则所有tools 都包括），其他按照你的思路更新；
